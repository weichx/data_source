import { EventEmitter } from './event';
import { Debouncer } from './util';
export interface ICollectionOptions {
    createdGroupOptions?: ICollectionOptions;
    sortItemsBy?: (a: any, b: any) => number;
    sortGroupsBy?: (a: Collection, b: Collection) => number;
    groupItemsBy?: ((a: any) => string) | string;
    filterItemsBy?: (a: any) => boolean;
    filterGroupsBy?: (a: Collection) => boolean;
    itemPageSize?: number;
    groupPageSize?: number;
    groupClass?: typeof Collection;
    synchronous?: boolean;
}
export declare var Event_Destroyed: string;
export declare var Event_ItemAdded: string;
export declare var Event_ItemRemoved: string;
export declare var Event_ItemChanged: string;
export declare var Event_GroupCreated: string;
export declare var Event_GroupDestroyed: string;
export declare var Event_GroupBecameActive: string;
export declare var Event_GroupBecameInactive: string;
export declare var Event_Refresh: string;
export declare class Collection extends EventEmitter {
    externalItems: Array<any>;
    externalGroups: Array<Collection>;
    protected pagedItems: Array<any>;
    protected pagedGroups: Array<Collection>;
    protected internalItems: Map<any, string>;
    protected itemSortFn: (a: any, b: any) => number;
    protected groupSortFn: (a: Collection, b: Collection) => number;
    protected itemFilterFn: (a: any) => boolean;
    protected groupFilterFn: (a: Collection) => boolean;
    protected getGroupIdFn: (a: any) => string;
    protected itemPageNumber: number;
    protected itemPageSize: number;
    protected groupPageNumber: number;
    protected groupPageSize: number;
    private changeList;
    isActive: boolean;
    id: string;
    protected groupMap: Map<string, Collection>;
    protected refreshDebouncer: Debouncer;
    protected createdGroupOptions: ICollectionOptions;
    protected groupClass: typeof Collection;
    constructor(initArrayOrOptions?: Array<any> | ICollectionOptions, options?: ICollectionOptions);
    idString: string;
    items: Array<any>;
    groups: Array<Collection>;
    itemsPaged: boolean;
    groupsPaged: boolean;
    isGrouped: boolean;
    itemPageCount: number;
    groupPageCount: number;
    currentItemPageNumber: number;
    currentGroupPageNumber: number;
    itemCount: number;
    groupCount: number;
    setOptions(options: ICollectionOptions): void;
    refresh(): void;
    setRefreshDebounceTime(debounceTime: number): void;
    pageGroups(pageNumber: number, pageSize: number): void;
    setGroupPageNumber(number: number): void;
    setGroupPageSize(pageSize: number): void;
    nextGroupPage(): void;
    previousGroupPage(): void;
    pageItems(pageNumber: number, pageSize: number): void;
    unpageItems(): void;
    setItemPageSize(size: number): void;
    setItemPageNumber(number: number): void;
    nextItemPage(): void;
    previousItemPage(): void;
    getGroupById(id: string): Collection;
    add(item: any): void;
    addArray(items: Array<any>): void;
    change(item: any, newItem?: any): void;
    changeArray(items: Array<any>): void;
    remove(item: any): void;
    removeArray(items: Array<any>): void;
    filterItemsBy(itemFilterFn: (a: any) => boolean): void;
    filterGroupsBy(groupFilterFn: (a: Collection) => boolean): void;
    sortItemsBy(itemSortFn: (a: any, b: any) => number): void;
    sortGroupsBy(groupSortFn: (a: Collection, b: Collection) => number): void;
    groupItemsBy(groupingFn: ((a: any) => string) | string): void;
    protected handleAsyncAdd(item: any): void;
    protected handleAsyncChange(item: any, newItem?: any): void;
    protected handleAsyncRemove(item: any): void;
    protected refreshGroups(): void;
    private emitGroupActivityChangeEvents(group);
    protected getGroup(item: any): Collection;
    clear(): void;
    protected regenerateGroups(): void;
    protected refreshItemFilters_Ungrouped(): void;
    protected refreshItemFilter_Grouped(): void;
    protected refreshSorting(): void;
    protected refreshItemPaging(): void;
    protected refreshGroupPaging(): void;
    protected activateGroup(group: Collection): void;
    protected deactivateGroup(group: Collection): void;
    getItemAt(index: number): any;
    getGroupAt(index: number): any;
    getUnfilteredItems(): Array<any>;
    getUnfilteredGroups(): Array<Collection>;
    forEachItem(fn: (item: any, index?: number, collection?: Array<any>) => void, ctx?: any): void;
    forEachGroup(fn: (group: Collection, index?: number, collection?: Array<Collection>) => void, ctx?: any): void;
    findItem(fn: (item: any, index?: number, collection?: Array<any>) => void, ctx?: any): any;
    findGroup(fn: (group: Collection, index?: number, collection?: Array<Collection>) => void, ctx?: any): Collection;
    findAllItems(fn: (item: any, index?: number, collection?: Array<any>) => void, ctx?: any): Array<any>;
    findAllGroups(fn: (groups: Collection, index?: number, collection?: Array<Collection>) => void, ctx?: any): Array<Collection>;
    everyItem(fn: (item: any) => boolean, ctx?: any): boolean;
    everyGroup(fn: (group: Collection) => boolean, ctx?: any): boolean;
}
export interface Map<K, V> {
    clear(): void;
    delete(key: K): boolean;
    forEach(callbackfn: (value: V, index?: K, map?: Map<K, V>) => void, thisArg?: any): void;
    get(key: K): V;
    has(key: K): boolean;
    set(key: K, value?: V): Map<K, V>;
    size: number;
}
export interface MapConstructor {
    new (): Map<any, any>;
    new <K, V>(): Map<K, V>;
    prototype: Map<any, any>;
}
